{
  "hash": "3dafb45b8bd0e626b8cb8a8f76a9a249",
  "result": {
    "markdown": "---\ntitle: Bootstrap Confidence Intervals for Standardized Solution in lavaan\nauthor: \"Shu Fai Cheung\"\ndate: '2022-09-28'\ncategories: [\"R\", \"lavaan\", \"bootstrapping\", \"confidence-intervals\", \"semhelpinghands\", \"standardized\"]\nbibliography: references.bib\ncsl: apa.csl\naliases:\n  - post/2022-09-28-bootstrap-confidence-intervals-for-standardized-solution-in-lavaan/index.html\n---\n\n\n\n`lavaan` supports bootstrap confidence\nintervals for free and user-defined\nparameters. This is useful especially for\nparameter estimates that may not be\napproximately normally distributed unless\nthe sample size is very large.\n\nHowever, it is known, though not well-known\nenough in my opinion, that, even if bootstrap\nconfidence intervals are requested, the\nconfidence intervals reported in the\nstandardized solution are not bootstrap\nconfidence intervals as in tools like\n`PROCESS` for standardized effects like\nstandardized indirect effects, but are\nsymmetric delta-method\nconfidence intervals based on the\nbootstrap\nsampling variance-covariance matrix.\n\nLet's use a sample dataset for illustration:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create the data\nset.seed(860541)\nn <- 100\nx <- rnorm(n)\nm <- .4 * x + rnorm(n, 0, sqrt(1 - .3^2))\ny <- .4 * m + rnorm(n, 0, sqrt(1 - .4^2))\ndat <- data.frame(x = 10 * x, m = 2 * m, y = 3 * y)\n```\n:::\n\n\nWe specify a simple regression model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lavaan)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThis is lavaan 0.6-13\nlavaan is FREE software! Please report any bugs.\n```\n:::\n\n```{.r .cell-code}\nmod <-\n\"\nm ~ a * x\ny ~ b * m + cp * x\nab := a * b\n\"\n```\n:::\n\n\n... and fit it with bootstrap confidence\nintervals (2023-01-28: Code and results\nupdated for `lavaan` 0.6-13, `iseed` is used\ninstead of `set.seed()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit <- sem(mod, data = dat, fixed.x = FALSE,\n           se = \"boot\", bootstrap = 2000,\n           iseed = 8970)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nLet's focus on the confidence intervals of\nthe indirect effect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest <- parameterEstimates(fit)\nstd <- standardizedSolution(fit)\n# Unstandardized\nest[7, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  lhs op rhs label   est    se     z pvalue ci.lower ci.upper\n7  ab := a*b    ab 0.025 0.015 1.686  0.092    0.001    0.059\n```\n:::\n\n```{.r .cell-code}\n# Standardized\nstd[7, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  lhs op rhs label est.std    se     z pvalue ci.lower ci.upper\n7  ab := a*b    ab   0.088 0.049 1.774  0.076   -0.009    0.185\n```\n:::\n:::\n\n\nThey lead to different conclusions.\n\nAs shown below, the confidence interval\nof the unstandardized indirect effect\nis percentile confidence interval that\nis asymmetric, as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nest[7, c(\"ci.lower\", \"ci.upper\")] - est[7, \"est\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ci.lower   ci.upper\n7 -0.02364024 0.03392409\n```\n:::\n:::\n\n\nHowever, the confidence interval of the\nstandardized indirect effect is symmetric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd[7, c(\"ci.lower\", \"ci.upper\")] - std[7, \"est.std\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     ci.lower   ci.upper\n7 -0.09699904 0.09699904\n```\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\nThis behavior has been discussed\nin the [Google group for`lavaan`](https://groups.google.com/g/lavaan) and\nso is known, but not \"well-known\" because\nI met many users who were not aware of this,\nespecially when they use bootstrapping to\nget the confidence intervals for indirect\neffects but found that the confidence\nintervals of unstandardized and\nstandardized indirect effect led to different\nconclusions, as in the example above.\n\nA solution already exists in `lavaan`.\nUsers can use\n`bootstrapLavaan()` and get the bootstrap\nconfidence intervals for many results,\nincluding\nthe output of standardized solution.\n\nWe first define a function to extract\nthe standardized indirect effect:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct <- function(fit) {\n    lavaan::standardizedSolution(fit)[7, \"est.std\"]\n  }\n```\n:::\n\n\nWe then update the fit object to disable\nstandard error because we only need the\npoint estimates and then call\n`bootstrapLavaan()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit0 <- update(fit, se = \"none\")\nfit_boot <- bootstrapLavaan(fit0, R = 2000, FUN = fct, iseed = 8970)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe percentile confidence interval\ncan then be formed by `quantile()`.\n\n(Note that `lavaan()` does not use `quantile()` but\nuse the approach by `boot.ci()`. The resulting\ninterval can be slightly different from that by `quantile()`.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(fit_boot[, 1], c(.025, .975))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       2.5%       97.5% \n0.004372947 0.196203435 \n```\n:::\n:::\n\n\nHowever, this is inconvenient because\nwe need to write\ncustom function, and\nbootstrapping was done twice unless\nwe store both the unstandardized and\nstandardized solutions in the custom\nfunction used when calling\n`bootstrapLavaan()`.\n\nI wrote the function\n[`standardizedSolution_boot_ci()`](https://sfcheung.github.io/semhelpinghands/reference/standardizedSolution_boot_ci.html), available in\nthe package [`semhelpinghands`](https://sfcheung.github.io/semhelpinghands/), for this\nparticular\ncase that I sometimes encounter:\n\n- A model is already fitted with\n `se = \"boot\"` and so bootstrap confidence\n intervals are already available for the\n unstandardized estimates.\n\n- I want to get the bootstrap\nconfidence intervals for the\nstandardized solution *without doing the bootstrapping again*.\n\nThis would be useful to\nme because some of my projects involve large\nsamples with missing data. and bootstrapping\ntakes appreciable time even with\nparallelization.\n\nThis is how to use this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(semhelpinghands)\nstd_boot <- standardizedSolution_boot_ci(fit)\n# -c(9, 10) is used to remove the delta-method CIs from\n# the printout\nstd_boot[, -c(9, 10)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  lhs op rhs label est.std    se      z pvalue boot.ci.lower boot.ci.upper\n1   m  ~   x     a   0.232 0.105  2.213  0.027         0.015         0.425\n2   y  ~   m     b   0.379 0.083  4.541  0.000         0.204         0.541\n3   y  ~   x    cp   0.103 0.092  1.117  0.264        -0.079         0.281\n4   m ~~   m         0.946 0.048 19.527  0.000         0.819         0.999\n5   y ~~   y         0.828 0.073 11.403  0.000         0.660         0.940\n6   x ~~   x         1.000 0.000     NA     NA            NA            NA\n7  ab := a*b    ab   0.088 0.049  1.774  0.076         0.004         0.196\n```\n:::\n:::\n\n\nThe `boot.ci` intervals are \"true\"\nbootstrap confidence intervals, formed\nfrom the bootstrap estimates. The\nbootstrap confidence interval for\nthe standardized indirect effect\n([0.004, 0.196])\nand that for the unstandardized\nindirect effect ([0.001, 0.059])\nnow lead to the same conclusion.\n\n`standardizedSolution_boot_ci()` works\nlike `standardizedSolution()`,\nbut extracts the stored bootstrap estimates,\nget the standardized solution from each\nset of estimates, and use them to form\nthe bootstrap confidence intervals for\nthe standardized solution.\n\nBy default, the bootstrap standardized\nsolution is also stored in the attribute\n`boot_est_std`. They can be extracted\nto examine the distribution. For example,\nthe bootstrap standardized indirect effects\ncan be extracted and plotted:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd_boot_est <- attr(std_boot, \"boot_est_std\")\nstd_indirect_boot_est <- std_boot_est[, 7]\nhist(std_indirect_boot_est)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\nqqnorm(std_indirect_boot_est)\nqqline(std_indirect_boot_est)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-2.png){width=672}\n:::\n:::\n\n\nThis function is simple to use, at least for\nme. No need to write custom function,\nand no need to do bootstrapping twice.\nIn most cases, I don't even need to\nspecify any additional arguments.\n\nMore about this function can be found\nin the [vignette](https://sfcheung.github.io/semhelpinghands/articles/standardizedSolution_boot_ci.html) for\n`standardizedSolution_boot_ci()`.\n\nIf any bug in `standardizedSolution_boot_ci()`\nwas found, I would appreciate submitting\nit as a [GitHub issue](https://github.com/sfcheung/semhelpinghands/issues).  {{< emoji \":smile:\" >}}",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}