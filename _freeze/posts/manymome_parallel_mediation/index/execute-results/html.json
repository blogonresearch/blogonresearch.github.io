{
  "hash": "e2b00597e95d1f1b2bb892ba3457fda9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Parallel Mediation in a Regression Model Using manymome: A Tutorial\"\nauthor: \"Shu Fai Cheung\"\ndate: '2024-09-14'\ncategories: [\"R\", \"mediation\", \"manymome\", \"bootstrapping\"]\nformat:\n  html:\n    toc: true\nbibliography: references.bib\ncsl: apa.csl\n---\n\n::: {.cell}\n\n:::\n\n\n\nThis tutorial shows how to use the R\npackage [`manymome`](https://sfcheung.github.io/manymome)\n[@cheung_manymome_2023]\nto test two or more mediation effects in\na parallel mediation model fitted by\nmultiple regression.\n\n# Pre-Requisite\n\nReaders are expected to have basic R\nskills and know how to fit a linear\nregression model using `lm()`.\n\nThe package `manymome` can be installed\nfrom CRAN:\n\n```r\ninstall.packages(\"manymome\")\n```\n\n# Data\n\nThis is the data file for illustration,\nfrom `manymome`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(manymome)\nhead(data_parallel, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         x       m1       m2        y       c1       c2\n1 9.652688 20.77622 8.977183 16.85574 2.385207 4.009182\n2 9.011756 18.28393 6.518089 15.99256 2.585124 5.980229\n3 9.343317 18.00133 6.271594 20.12393 2.667239 4.170771\n```\n\n\n:::\n:::\n\n\n\n# A Parallel Mediation Model\n\nFirst we fit a parallel mediation\nmodel using\nonly `x`, `m1`, `m2`, and `y`.\n\n\n\n::: {.cell layout-align=\"center\" fig-heigh='3'}\n::: {.cell-output-display}\n![A Parallel Mediation Model](index_files/figure-html/fig-full-model-1.png){#fig-full-model fig-align='center' width=576}\n:::\n:::\n\n\n\nIn this model:\n\n- `x` is the predictor\n(independent variable).\n\n- `y` is the\noutcome variable (dependent variable).\n\n- `m1` and `m2` are the mediators.\n\nThe goal is to compute and test the\ntwo indirect effects:\n\n- From `x` to `y`  through `m1`.\n\n- From `x` to `y`  through `m2`.\n\n# Fit the Models by `lm()`\n\nTo estimate all the regression coefficients,\njust fit three regression\nmodels:\n\n- Predict `m1` by `x` (@fig-m1-model).\n\n- Predict `m2` by `x` (@fig-m2-model).\n\n- Predict `y` by `m1`, `m2`, and `x` (@fig-y-model).\n\n\n\n::: {.cell layout-align=\"center\" fig-heigh='3'}\n::: {.cell-output-display}\n![The Model Predicting `m1`](index_files/figure-html/fig-m1-model-1.png){#fig-m1-model fig-align='center' width=576}\n:::\n:::\n\n::: {.cell layout-align=\"center\" fig-heigh='3'}\n::: {.cell-output-display}\n![The Model Predicting `m2`](index_files/figure-html/fig-m2-model-1.png){#fig-m2-model fig-align='center' width=576}\n:::\n:::\n\n::: {.cell layout-align=\"center\" fig-heigh='3'}\n::: {.cell-output-display}\n![The Model Predicting `y`](index_files/figure-html/fig-y-model-1.png){#fig-y-model fig-align='center' width=576}\n:::\n:::\n\n\n\nThis can be easily done by `lm()` in R:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predict m1\nmodel_m1 <- lm(m1 ~ x,\n               data = data_parallel)\n# Predict m2\nmodel_m2 <- lm(m2 ~ x,\n               data = data_parallel)\n# Predict y\nmodel_y <- lm(y ~ m1 + m2 + x,\n              data = data_parallel)\n```\n:::\n\n\n\nThese are the regression results:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_m1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = m1 ~ x, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   9.0203     1.1288   7.991 2.65e-12 ***\nx             0.9247     0.1128   8.200 9.49e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.125 on 98 degrees of freedom\nMultiple R-squared:  0.4069,\tAdjusted R-squared:  0.4009 \nF-statistic: 67.24 on 1 and 98 DF,  p-value: 9.488e-13\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_m2)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = m2 ~ x, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   2.5066     1.1248   2.229 0.028128 *  \nx             0.3921     0.1124   3.490 0.000726 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.121 on 98 degrees of freedom\nMultiple R-squared:  0.1105,\tAdjusted R-squared:  0.1015 \nF-statistic: 12.18 on 1 and 98 DF,  p-value: 0.000726\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_y)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = y ~ m1 + m2 + x, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)  \n(Intercept)   2.4554     2.6015   0.944   0.3476  \nm1            0.4784     0.1861   2.571   0.0117 *\nm2            0.4684     0.1867   2.508   0.0138 *\nx             0.3003     0.2646   1.135   0.2593  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.017 on 96 degrees of freedom\nMultiple R-squared:  0.2823,\tAdjusted R-squared:  0.2599 \nF-statistic: 12.59 on 3 and 96 DF,  p-value: 5.212e-07\n```\n\n\n:::\n:::\n\n\n\nThe direct effect is the\ncoefficient of `x` in the\nmodel predicting `y`, which\nis 0.300, and\nnot significant.\n\n# The Indirect Effects\n\nThe two indirect effects are the product of\nthe `a1`-path and `b1`-path and that\nof the `a2`-path and `b2`-path,\nrespectively:\n\n- `x` -> `m1` -> `y`\n\n    - Computed by `a1` &times; `b1`\n\n- `x` -> `m2` -> `y`\n\n    - Computed by `a2` &times; `b2`\n\nTo test\nthese indirect effects, one common method\nis nonparametric bootstrapping [@cheung_comparison_2009\n@mackinnon_comparison_2002].\nThis can be done easily by `indirect_effect()`\nfrom the package `manymome`.\n\n## Combine the Regression Results\n\nWe first combine the regression models\nby [`lm2list()`](https://sfcheung.github.io/manymome/reference/lm2list.html)\ninto one object to represent the whole model\n(@fig-full-model):[^order]\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_model <- lm2list(model_m1,\n                      model_m2,\n                      model_y)\nfull_model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nThe models:\nm1 ~ x\nm2 ~ x\ny ~ m1 + m2 + x\n```\n\n\n:::\n:::\n\n\n\n[^order]: The order does not matter when using\n`lm2list`.\n\n## Compute and Test the Indirect Effect\n\nFor this parallel mediation model, we can simply use\n[`indirect_effect()`](https://sfcheung.github.io/manymome/reference/cond_indirect.html)\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind1 <- indirect_effect(x = \"x\",\n                        y = \"y\",\n                        m = \"m1\",\n                        fit = full_model,\n                        boot_ci = TRUE,\n                        R = 5000,\n                        seed = 3456)\n```\n:::\n\n\n\nThese are the main arguments:\n\n- `x`: The name of the `x` variable,\n  the start of the indirect path.\n\n- `y`: The name of the `y` variable,\n  the end of the indirect path.\n\n- `m`: The name of the mediator, `m1`\n  in the above example.\n\n- `fit`: The regression models combined\n  by `lm2list()`.\n\n- `boot_ci`: If `TRUE`, bootstrap\n  confidence interval will be formed.\n\n- `R`, the number of bootstrap samples.\n  It is fast for regression models and\n  I recommend using at least 5000\n  bootstrap samples or even 10000, because\n  the results may not be stable enough\n  if indirect effect is close to zero\n  [an example can be found in @cheung_semlbci_2023].\n\n- `seed`: The seed for the random number\n  generator, to make the resampling\n  reproducible. This argument should\n  always be set when doing bootstrapping.\n\nBy default, parallel processing will\nbe used and a progress bar will be\ndisplayed.\n\nThe other indirect effect can be computed\nsimilarly:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind2 <- indirect_effect(x = \"x\",\n                        y = \"y\",\n                        m = \"m2\",\n                        fit = full_model,\n                        boot_ci = TRUE,\n                        R = 5000,\n                        seed = 3456)\n```\n:::\n\n\n\nJust typing the name of the output can\nprint the major results\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                     \n Path:               x -> m1 -> y    \n Indirect Effect:    0.442           \n 95.0% Bootstrap CI: [0.103 to 0.803]\n\nComputation Formula:\n  (b.m1~x)*(b.y~m1)\nComputation:\n  (0.92471)*(0.47840)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m1~x       0.925\n y~m1       0.478\n```\n\n\n:::\n\n```{.r .cell-code}\nind2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                     \n Path:               x -> m2 -> y    \n Indirect Effect:    0.184           \n 95.0% Bootstrap CI: [0.027 to 0.402]\n\nComputation Formula:\n  (b.m2~x)*(b.y~m2)\nComputation:\n  (0.39215)*(0.46844)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m2~x       0.392\n y~m2       0.468\n```\n\n\n:::\n:::\n\n\n\nAs shown above, the indirect effect\nthrough `m1` is\n0.442.\nThe 95% bootstrap confidence interval is\n[0.103; 0.803]. The indirect effect\nis positive and significant.\n\nAs shown above, the indirect effect\nthrough `m2` is\n0.184.\nThe 95% bootstrap confidence interval is\n[0.027; 0.402]. The indirect effect\nis positive and significant.\n\nFor transparency, the output also shows\nhow the indirect effect was computed.\n\n## Standardized Indirect Effect\n\nTo compute and test the standardized\nindirect effect, with both the `x`-variable\nand `y`-variable standardized, add\n`standardized_x = TRUE` and\n`standardized_y = TRUE`:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind1_stdxy <- indirect_effect(x = \"x\",\n                              y = \"y\",\n                              m = \"m1\",\n                              fit = full_model,\n                              boot_ci = TRUE,\n                              R = 5000,\n                              seed = 3456,,\n                              standardized_x = TRUE,\n                              standardized_y = TRUE)\nind2_stdxy <- indirect_effect(x = \"x\",\n                              y = \"y\",\n                              m = \"m2\",\n                              fit = full_model,\n                              boot_ci = TRUE,\n                              R = 5000,\n                              seed = 3456,,\n                              standardized_x = TRUE,\n                              standardized_y = TRUE)\n```\n:::\n\n\n\nThe results can be printed as usual:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind1_stdxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect (Both 'x' and 'y' Standardized) ==\n                                     \n Path:               x -> m1 -> y    \n Indirect Effect:    0.189           \n 95.0% Bootstrap CI: [0.045 to 0.340]\n\nComputation Formula:\n  (b.m1~x)*(b.y~m1)*sd_x/sd_y\nComputation:\n  (0.92471)*(0.47840)*(1.00306)/(2.34506)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m1~x       0.925\n y~m1       0.478\n\nNOTE:\n- The effects of the component paths are from the model, not\n  standardized.\n```\n\n\n:::\n\n```{.r .cell-code}\nind2_stdxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect (Both 'x' and 'y' Standardized) ==\n                                     \n Path:               x -> m2 -> y    \n Indirect Effect:    0.079           \n 95.0% Bootstrap CI: [0.013 to 0.166]\n\nComputation Formula:\n  (b.m2~x)*(b.y~m2)*sd_x/sd_y\nComputation:\n  (0.39215)*(0.46844)*(1.00306)/(2.34506)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m2~x       0.392\n y~m2       0.468\n\nNOTE:\n- The effects of the component paths are from the model, not\n  standardized.\n```\n\n\n:::\n:::\n\n\n\nThe standardized indirect effect\nthrough `m1`\nis\n0.189.\nThe 95% bootstrap confidence interval is\n[0.045; 0.340], significant.\n\nThe standardized indirect effect\nthrough `m2`\nis\n0.079.\nThe 95% bootstrap confidence interval is\n[0.013; 0.166], significant.\n\n# Total Indirect Effect\n\nSuppose we would like to compute the\ntotal indirect effects from `x` to `y`\nthrough the two parallel paths. This\ncan be done by \"adding\"\nthe indirect effects computed above,\nsimply by using the `+` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind_total <- ind1 + ind2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind_total\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                      \n Path:                x -> m1 -> y    \n Path:                x -> m2 -> y    \n Function of Effects: 0.626           \n 95.0% Bootstrap CI:  [0.276 to 1.065]\n\nComputation of the Function of Effects:\n (x->m1->y)\n+(x->m2->y) \n\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n```\n\n\n:::\n:::\n\n\n\nThe standardized total indirect effect\ncan be computed similarly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind_total_stdxy <- ind1_stdxy + ind2_stdxy\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind_total_stdxy\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect (Both 'x' and 'y' Standardized) ==\n                                      \n Path:                x -> m1 -> y    \n Path:                x -> m2 -> y    \n Function of Effects: 0.268           \n 95.0% Bootstrap CI:  [0.122 to 0.431]\n\nComputation of the Function of Effects:\n (x->m1->y)\n+(x->m2->y) \n\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n```\n\n\n:::\n:::\n\n\n\nThe total indirect effect\nthrough the two paths is\n0.626.\nThe 95% bootstrap confidence interval is\n[0.276; 1.065], significant.\n\nThe total standardized indirect effect\nthrough the two paths is\n0.268.\nThe 95% bootstrap confidence interval is\n[0.122; 0.431]\n\n# Difference in Indirect Effects\n\nThe indirect effects through the two\npaths are substantially different\n(0.442 vs. 0.184).\nSuppose we would like to compare the\ntwo paths by computing the *difference*\nin indirect effect and forming the\nbootstrap confidence interval of this\ndifference. This can be done by\nliterally computing the difference using\nthe `-` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind_diff <- ind1 - ind2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind_diff\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                       \n Path:                x -> m1 -> y     \n Path:                x -> m2 -> y     \n Function of Effects: 0.259            \n 95.0% Bootstrap CI:  [-0.165 to 0.659]\n\nComputation of the Function of Effects:\n (x->m1->y)\n-(x->m2->y) \n\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n```\n\n\n:::\n:::\n\n\n\nInterestingly, despite the apparent\nmagnitude of the difference, the two\nindirect effects are not significantly\ndifferent, probably due to the small\nsample size (100).\n\nThe difference in standardized indirect\neffects (0.189 vs. 0.079)\ncan be computed similarly:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind_stdxy_diff <- ind1_stdxy - ind2_stdxy\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind_stdxy_diff\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect (Both 'x' and 'y' Standardized) ==\n                                       \n Path:                x -> m1 -> y     \n Path:                x -> m2 -> y     \n Function of Effects: 0.111            \n 95.0% Bootstrap CI:  [-0.072 to 0.281]\n\nComputation of the Function of Effects:\n (x->m1->y)\n-(x->m2->y) \n\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n```\n\n\n:::\n:::\n\n\n\n# A Parallel Mediation Model With Some Control Variables\n\nSuppose we want to fit a more complicated\nmodel, with some other variables included,\nsuch as control variables `c1` and `c2`\nin the dataset (@fig-full-model2).\n\n\n\n::: {.cell layout-align=\"center\" fig-caption='A Parallel Mediation Model With Control Variables' fig-heigh='5'}\n::: {.cell-output-display}\n![](index_files/figure-html/fig-full-model2-1.png){#fig-full-model2 fig-align='center' width=576}\n:::\n:::\n\n\n\nAlthough there are more predictors (`c1`\nand `c2`) and more direct and indirect\npaths (e.g., `c1` to `y` through `m1`),\nthere are still only just three regression\nmodels. We can fit them as usual by\n`lm()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel2_m1 <- lm(m1 ~ x + c1 + c2,\n                data = data_parallel)\nmodel2_m2 <- lm(m2 ~ x + c1 + c2,\n                data = data_parallel)\nmodel2_y <- lm(y ~ m1 + m2 + x + c1 + c2,\n               data = data_parallel)\n```\n:::\n\n\n\nThese are the regression results:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model2_m1)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = m1 ~ x + c1 + c2, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  9.39260    1.40019   6.708 1.37e-09 ***\nx            0.87694    0.11441   7.665 1.45e-11 ***\nc1           0.25189    0.11131   2.263   0.0259 *  \nc2          -0.09293    0.12255  -0.758   0.4501    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.106 on 96 degrees of freedom\nMultiple R-squared:  0.4394,\tAdjusted R-squared:  0.4219 \nF-statistic: 25.08 on 3 and 96 DF,  p-value: 4.558e-12\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model2_m2)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = m2 ~ x + c1 + c2, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept)   4.3796     1.3463   3.253  0.00158 **\nx             0.2968     0.1100   2.698  0.00825 **\nc1            0.2746     0.1070   2.566  0.01185 * \nc2           -0.3125     0.1178  -2.652  0.00937 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.063 on 96 degrees of freedom\nMultiple R-squared:  0.2171,\tAdjusted R-squared:  0.1927 \nF-statistic: 8.875 on 3 and 96 DF,  p-value: 3e-05\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model2_y)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nCall:\nlm(formula = y ~ m1 + m2 + x + c1 + c2, data = data_parallel)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)  \n(Intercept)  2.65618    3.17697   0.836   0.4052  \nm1           0.48642    0.19106   2.546   0.0125 *\nm2           0.47128    0.19871   2.372   0.0197 *\nx            0.29112    0.26939   1.081   0.2826  \nc1          -0.05256    0.21557  -0.244   0.8079  \nc2          -0.03212    0.23411  -0.137   0.8912  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.038 on 94 degrees of freedom\nF-statistic:  7.42 on 5 and 94 DF,  p-value: 6.649e-06\n```\n\n\n:::\n:::\n\n\n\nWe then just combine them by `lm2list()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_model2 <- lm2list(model2_m1,\n                       model2_m2,\n                       model2_y)\nfull_model2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nThe models:\nm1 ~ x + c1 + c2\nm2 ~ x + c1 + c2\ny ~ m1 + m2 + x + c1 + c2\n```\n\n\n:::\n:::\n\n\n\nThe indirect effects can be computed\nand tested in exactly the same way:\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind2_1 <- indirect_effect(x = \"x\",\n                          y = \"y\",\n                          m = \"m1\",\n                          fit = full_model2,\n                          boot_ci = TRUE,\n                          R = 5000,\n                          seed = 3456)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nind2_2 <- indirect_effect(x = \"x\",\n                          y = \"y\",\n                          m = \"m2\",\n                          fit = full_model2,\n                          boot_ci = TRUE,\n                          R = 5000,\n                          seed = 3456)\n```\n:::\n\n\n\nThis is the result:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind2_1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                     \n Path:               x -> m1 -> y    \n Indirect Effect:    0.427           \n 95.0% Bootstrap CI: [0.095 to 0.804]\n\nComputation Formula:\n  (b.m1~x)*(b.y~m1)\nComputation:\n  (0.87694)*(0.48642)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m1~x       0.877\n y~m1       0.486\n```\n\n\n:::\n\n```{.r .cell-code}\nind2_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                     \n Path:               x -> m2 -> y    \n Indirect Effect:    0.140           \n 95.0% Bootstrap CI: [0.006 to 0.359]\n\nComputation Formula:\n  (b.m2~x)*(b.y~m2)\nComputation:\n  (0.29677)*(0.47128)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m2~x       0.297\n y~m2       0.471\n```\n\n\n:::\n:::\n\n\n\nThe indirect effect through\n`m1`\nis\n0.427.\nThe 95% bootstrap confidence interval is\n[0.095; 0.804], slightly decreased after the\ncontrol variables are included, but\nstill significant.\n\nThe indirect effect through\n`m2`\nis\n0.140.\nThe 95% bootstrap confidence interval is\n[0.006; 0.359], decreased after the\ncontrol variables are included, but\nstill significant.\n\nStandardized indirect effects can also\nbe computed and tested just by adding\n`standardized_x = TRUE` and\n`standardized_y = TRUE`.\n\nThe total indirect effect can also be\ncomputed using `+`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nind2_total <- ind2_1 + ind2_2\nind2_total\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                      \n Path:                x -> m1 -> y    \n Path:                x -> m2 -> y    \n Function of Effects: 0.566           \n 95.0% Bootstrap CI:  [0.227 to 1.020]\n\nComputation of the Function of Effects:\n (x->m1->y)\n+(x->m2->y) \n\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\n```\n\n\n:::\n:::\n\n\n\n# No Limit On The Number of Mediators\n\nAlthough the example above only has two\nmediators, there is no limit on the\nnumber of mediators in the parallel\nmediation model. Just fit all the\nregression models predicting the mediators,\ncombine them by `lm2list()`, and compute\nthe indirect effect as illustrated above\nfor each path.\n\n# Advanced Topics\n\n## Customize the Printout\n\nThe printout can be customized in\nseveral ways. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(ind1,\n      digits = 2,\n      pvalue = TRUE,\n      pvalue_digits = 3,\n      se = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n== Indirect Effect  ==\n                                   \n Path:               x -> m1 -> y  \n Indirect Effect:    0.44          \n 95.0% Bootstrap CI: [0.10 to 0.80]\n Bootstrap p-value:  0.006         \n Bootstrap SE:       0.18          \n\nComputation Formula:\n  (b.m1~x)*(b.y~m1)\nComputation:\n  (0.92471)*(0.47840)\n\nPercentile confidence interval formed by nonparametric bootstrapping\nwith 5000 bootstrap samples.\nStandard error (SE) based on nonparametric bootstrapping with 5000\nbootstrap samples.\n\nCoefficients of Component Paths:\n Path Coefficient\n m1~x        0.92\n y~m1        0.48\n```\n\n\n:::\n:::\n\n\n\n- `digits`: The number of digits after\n  the decimal point for major output.\n  Default is 3.\n\n- `pvalue`: Whether bootstrapping\n  *p*-value is printed. The method\n  by @asparouhov_bootstrap_2021 is used.\n\n- `pvalue_digits`: The number of digits\n  after the decimal point for the\n  *p*-value. Default is 3.\n\n- `se`: The standard error based on\n  bootstrapping (i.e., the standard\n  deviation of the bootstrap estimates).\n\n## Missing Data\n\nCare needs to be taken if missing data\nis present. Let's remove some data\npoints from the data file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_parallel_missing <- data_parallel\ndata_parallel_missing[1:3, \"x\"] <- NA\ndata_parallel_missing[2:4, \"m1\"] <- NA\ndata_parallel_missing[3:5, \"m2\"] <- NA\ndata_parallel_missing[3:6, \"y\"] <- NA\nhead(data_parallel_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         x       m1       m2        y       c1       c2\n1       NA 20.77622 8.977183 16.85574 2.385207 4.009182\n2       NA       NA 6.518089 15.99256 2.585124 5.980229\n3       NA       NA       NA       NA 2.667239 4.170771\n4 9.272600       NA       NA       NA 2.021972 3.819458\n5 9.845673 18.29027       NA       NA 3.796376 4.375370\n6 9.147475 18.21173 7.167020       NA 3.686640 5.283557\n```\n\n\n:::\n:::\n\n\n\nIf we do the regression separately,\nthe cases used in the two models will\nbe different:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predict m1\nmodel_m1_missing <- lm(m1 ~ x,\n                      data = data_parallel_missing)\nmodel_m2_missing <- lm(m2 ~ x,\n                      data = data_parallel_missing)\n# Predict y\nmodel_y_missing <- lm(y ~ m1 + m2 + x,\n                      data = data_parallel_missing)\n```\n:::\n\n\n\nThe sample sizes are not the same:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnobs(model_m1_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 96\n```\n\n\n:::\n\n```{.r .cell-code}\nnobs(model_m2_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 95\n```\n\n\n:::\n\n```{.r .cell-code}\nnobs(model_y_missing)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 94\n```\n\n\n:::\n:::\n\n\n\nIf they are combined by `lm2list()`,\nan error will occur. The function `lm2list()`\nwill compare the data to see if the cases\nused are likely to be different.[^compare]\n\n[^compare]: The function `lm2list()` checks\nnot only sample sizes. Even if the sample\nsizes are the same, an error will still\nbe raised if there is evidence suggesting\nthat the samples are not the same, such\nas different values of `x` in the two\nmodels.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm2list(model_m1_missing,\n        model_m2_missing,\n        model_y_missing)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in check_lm_consistency(...): The data sets used in the lm models do not have identical sample size. All lm models must be fitted to the same sample.\n```\n\n\n:::\n:::\n\n\n\nA simple (though not ideal) solution is\nto use listwise deletion, keeping only\ncases with complete data. This can be done\nby `na.omit()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_parallel_listwise <- na.omit(data_parallel_missing)\nhead(data_parallel_listwise)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           x       m1       m2        y        c1       c2\n7  10.602289 17.75832 5.944234 18.76106  1.570251 5.629544\n8  10.244337 19.31993 6.367723 21.26092  2.140513 5.243080\n9   8.877403 16.03285 4.035743 15.64276  2.697043 6.316437\n10  9.995130 17.84715 6.219250 12.16667  1.557163 5.536002\n11  9.214953 17.30516 6.416709 15.66863  3.157459 6.613625\n12 10.178196 17.76963 4.411447 18.68844 -0.127799 5.796077\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(data_parallel_listwise)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 94\n```\n\n\n:::\n:::\n\n\n\nThe number of cases using listwise deletion\nis 94, less than\nthe full sample with missing data\n(94).\n\nThe steps above can then be proceed as\nusual.\n\n# Functions Used In This Example\n\nThese are the main functions used:\n\n- [`lm2list()`](https://sfcheung.github.io/manymome/reference/lm2list.html): Combining the results of\n  several one-outcome regression models.\n\n- [`indirect_effect()`](https://sfcheung.github.io/manymome/reference/cond_indirect.html): Compute\n  and test an indirect effect.\n\n# Further Information\n\nThe package `manymome` has no inherent\nlimitations on the number of variables and\nthe form of the mediation models. An\nillustration using a more complicated\nmodels with both parallel and serial\nmediation paths can be found in\n[this online article](https://sfcheung.github.io/manymome/articles/med_lm.html).\n\nOther features of `manymome` can be\nfound in [the website](https://sfcheung.github.io/manymome/)\nfor it.\n\n# Disclaimer: Similarity Across Tutorials\n\nTo keep each tutorial self-contained,\nsome sections are intentionally repeated\nnearly verbatim (\"recycled\")\nto reduce the hassle to read several articles\nto learn how to do one task.\n\n# Revision History and Issues\n\nThe revision history of this post can\nbe find in the [GitHub history of\nthe source file](https://github.com/blogonresearch/blogonresearch.github.io/commits/main/posts/manymome_simple_mediation/index.qmd).\n\nFor issues on this post, such as corrections\nand mistakes, please [open an issue](https://github.com/blogonresearch/blogonresearch.github.io/issues)\nfor the GitHub repository for this blog.\nThanks.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}